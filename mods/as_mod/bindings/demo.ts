// The namespace 'demo' is derived from the filename
// Bindings are hand-written not autogenerated.

// Should inline all probably

@external("counter()")
export declare function counter(): void

@external("print(u32)")
export declare function print_u32(value: u32): void

@external("rand() u64")
export declare function rand(): u64

export function hostmath(a: u8, b: i16, c: u8): bool{
    return externs.demo.hostmath(a, b, c) as bool
}

// TODO: Multi-value support still missing.
// export function rand_2(): [u32, bool]{
//     const [a, b] = externs.demo.rand_2();
//     return [a, b as bool];
// }

/// IDK TS: This should only be 12 elements long
export function print_buffer(value: StaticArray<u8>): void{
    return externs.demo.print_buffer(value);
}

// FIXME:? Expensive UTF16->8. Is this even fixable in JS-likes?
export function print(str: string): void{
    return externs.demo.print(String.UTF8.encode(str, false), str.length)
}

// Returns a 24 element array of u64.
export function rand_buf(): Uint64Array{
    // Allocate buffer of 24
    let buffer = new ArrayBuffer(64/8 * 24);
    externs.demo.rand_buf(buffer);
    // Reinterpret
    const view = Uint64Array.wrap(buffer);
    return view;
}

export function receive_big_buffer(): Uint8Array{
    let buffer = new ArrayBuffer(104857600);
    externs.demo.receive_big_buffer(buffer);
    return Uint8Array.wrap(buffer);
}

export function receive_string(): String | ReceiveArbitraryResult{
    // Packages two underlying calls together and JS string conversion
    let len = externs.demo.prepare_arbitrary_string();
    let utf8buf = new ArrayBuffer(len);
    let trfres = receive_arbitrary_enum(utf8buf);
    if(trfres != ReceiveArbitraryResult.SUCCESS){
        return trfres;
    }
    let result = String.UTF8.decode(utf8buf);
    // const decode = new TextDecoder(); // NOT IMPLEMENTED
    return result;
}

//---------------------------------------------------------
export function receive_arbitrary_enum(a: ArrayBuffer): ReceiveArbitraryResult{
    return externs.demo.receive_arbitrary(a) as ReceiveArbitraryResult
}
enum ReceiveArbitraryResult{
    SUCCESS = 0,
    GENERIC_FAIL = 1,
    NOT_PREPARED = 2
}
//---------------------------------------------------------

// Contains underlying functions of types requiring wrapping
namespace externs{
    type WASMPointer = usize;
export declare namespace demo {
    // @external("counter()")
    // @external("print(u32)")
    // @external("rand() u64")

    @external("hostmath(u8 i16 u8) bool8")
    export function hostmath(a: u8, b: i16, c: u8): u8

    // @external("rand() (u32, bool8)") - SKIPPED due to missing features
    // export function rand_2(): [u32, u8]

    @external("print(ptr)") // pointer to 12 u8. Passing types passes a pointer to their data, and StaticArray has no extra abstraction
    export function print_buffer(a: StaticArray<u8>): void

    @external("print(ptr, u32)")
    export function print(a: ArrayBuffer, b: u32): void

    @external("rand(ptr)")
    export function rand_buf(a: ArrayBuffer): void

    @external("receive_big_buffer(ptr)")
    export function receive_big_buffer(a: ArrayBuffer): void

    // This doesn't require any reintrepretation, but we don't want to easily publicise it to the mod developer because its error prone on its own
    // It should always be followed up be receive_arbitrary.
    @external("receive_arbitrary(ptr) enum8")
    export function receive_arbitrary(a: ArrayBuffer): u8

    @external("prepare_arbitrary_string() usize")
    export function prepare_arbitrary_string(): u32
}
}