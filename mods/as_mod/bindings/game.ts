// Bindings are hand-written not autogenerated.

class u128_parts{
    low: u64
    high: u64
    constructor(low: u64, high: u64){
        this.low = low
        this.high = high
    }
}

export declare function hello(): void
export declare function fncounter(): void
export declare function printnumber(value: u32): void
export declare function rand64(): u64

namespace raw{
    type ptr<T> = usize
    @external("game", "recv128")
    export declare function recv128(dst: ptr<u128_parts>): void
    @external("game", "print")
    export declare function print(src: ptr<u8>, len: u32): void
    @external("game", "getline")
    export declare function getline(): u64
    @external("game", "bulkdump")
    export declare function bulkdump(dst: ptr<u8>): bool
}

export function recv128(): u128_parts {
    let dstbuf = new Uint64Array(2)
    raw.recv128(dstbuf.dataStart)
    // Decoding by hand since AS doesn't appear to have a way to paste directly over a pointer.
    return new u128_parts(dstbuf[0], dstbuf[1])
}
// Add other overloads for standard types as needed
export function print(s: string): void{
    let srcbuf = String.UTF8.encode(s, false)
    let ptr = new DataView(srcbuf).dataStart
    raw.print(ptr, srcbuf.byteLength)
}
export function getline(): string | null {
    // Abstracting over the two calls to create a simple string interface in JS-UTF16 world.
    let resultpacked = raw.getline()
    let success = (resultpacked >> 32) != 0
    if(!success) return null
    let length = (resultpacked & 0xFFFF_FFFF) as u32
    let dstbuf = new Uint8Array(length)
    let _ = raw.bulkdump(dstbuf.dataStart)
    return String.UTF8.decode(dstbuf.buffer) // there's a copy here
}